<h2>Module Trees</h2>

<h3>Submodules</h3>

<p>There are two principal approaches to build up the module tree that will create the runtime tree of your application.
In both scenarios a module will use another module, which I will call a submodule.
From these submodules the module will inject components into components that itself declares.
That is how modules are connected in ModuleInject and how dependencies of components between different modules are resolved.</p>

<p>In and by itself this is a pretty simple setup. Take some components from a submodule and put them in some components that 
I create.
The interesting problem is now how to provide modules with submodules.</p>

<h4>Direct resolution</h4>

<p>The simplest approach is to declare a submodule as a private or public component of the module. 
That means the submodule is created by the module itself. 
No problem and no headache at all. </p>

<pre><code>public class ParentModule : InjectionModule&lt;...&gt;, ...
{
    private IComponent PublicComponent { get; private set;}

    // this submodule must implement IInjectionModule to be recognized as a submodule
    [PrivateComponent]
    private ISubModule SubModule { get; private set; }

    public ParentModule() 
    {
        // this results in the submodule being created when the module is resolved
        RegisterPrivateComponent&lt;ISubModule, SubModule&gt;(x =&gt; x.SubModule);

        // this injects the SubComponent property of the submodule into the SomeSubComponent
        // property of the PublicComponent
        RegisterPublicComponent&lt;IComponent, Component&gt;(x =&gt; x.PublicComponent)
            .Inject(x =&gt; x.SubModule.SubComponent).IntoProperty(x =&gt; x.SomeSubComponent);
    }
}
</code></pre>

<p>It only becomes a problem when you want to use the submodule in different parts of your application. In that situation you
would have to distribute it over complex injection between modules. And you probably don't want that.</p>

<h3>Registry resolution</h3>

<p>Another slightly more complicated approach to distribute submodules is the use of one or several registries.
A registry is a class that derives from <code>IRegistry</code>. It is used to register modules that can be resolved.
This is different to most full blown IoC containers where an interface/type and some string keys can be combined to 
register and resolve a type. A registry only offers the possibility to register a module via its interface.</p>

<pre><code>IRegistry registry = new Registry();
registry.RegisterModule&lt;ISubModule, SubModule&gt;();
</code></pre>

<p>With this registry you could resolve the submodule in aboves <code>ParentModule</code> as follows:</p>

<pre><code>public class ParentModule : InjectionModule&lt;...&gt;, ...
{
    private IComponent PublicComponent { get; private set;}

    [RegistryComponent]
    private ISubModule SubModule { get; private set; }

    public ParentModule() 
    {
        // you can inject the submodule without further fuss
        // the module will automatically take the submodule from the registry
        RegisterPublicComponent&lt;IComponent, Component&gt;(x =&gt; x.PublicComponent)
            .Inject(x =&gt; x.SubModule.SubComponent).IntoProperty(x =&gt; x.SomeSubComponent);
    }
}
</code></pre>

<p>For the registry to be available in the module we can do the following:</p>

<pre><code>ParentModule parentModule = new ParentModule();

// from above
parentModule.Registry = registry; 

// now the registry will be used to resolve the submodule
parentModule.Resolve(); 
</code></pre>

<h3>MEF Registries</h3>

<p>To make the module resolution in registries less cumbersome or more flexible you can use a MEF registry.
These registries use MEF to load the modules that they distribute accross your module tree.</p>

<p>The creation of such a registry is relatively simple. You derive from <code>MefRegistryBase</code> and do something like the
following:</p>

<pre><code>public class MyMefRegistry : MefRegistryBase 
{
    // imports a submodule which will be available 
    // in all modules that use the registry
    [Import]
    ISubModule SubModule { get; private set; }

    public MyMefRegistry() 
    {
         // you can add any type of MEF catalog you want
         // here we search for modules in the current assembly
         var catalog = new AssemblyCatalog(System.Reflection.Assembly.GetExecutingAssembly());
         this.AddCatalog(catalog);
    }
}
</code></pre>

<p>Then apply the registry to a module and everything is done.</p>

<h3>Registry Merge</h3>

<p>Registry are somewhat complex because they are handed down from a module to each of its submodules. This means that
applying a registry on the root of a module tree will make the modules in the registry available to all modules in the tree.
In that way it is very simple to get common modules distributed over all your other modules.</p>

<p>This means in our examples above the <code>ISubModule</code> submodule in the <code>ParentModule</code> will also have access to the registry of
its parent.</p>

<p>In most of the cases this is a very nice feature. In some cases however you want additional or different modules to be
available in a subtree of your module tree. To enable this different registries can be applied to each module in the tree.
Whenever a registry is encountered in a module it is merged with the registry that was applied in the resolution of its 
parent module.</p>

<p>Note that types in the local registry of the module take priority over types in the parent registry. Also be warned that
a module which is placed in different subtrees with different registries, it will only be resolved once with the registry
of the subtree it is resolved in first.</p>
